本作业使用 disk.py 来帮助读者熟悉现代磁盘的工作原理。
它有很多不同的选项，与大多数其他模拟不同，它有图形动画，
可以准确显示磁盘运行时发生的情况。详情请参阅 README 文件。

问题：

<br/>
<br/>
1.计算以下几组请求的寻道、旋转和传输时间: `-a 0，-a 6，-a 30，-a 7，30，8`，
最后计算 `-a 10,11,12,13`

```shell script
python2 disk.py  -a 0 -G
python2 disk.py  -a 30 -G
python2 disk.py  -a 7,30,8 -G
python2 disk.py  -a 10,11,12,13 -G
```
总时间为：

<br/>
<br/>
1. 5.5 * 30 + 30 = 195.0
<br/>
<br/>
2. 11.5 * 30 + 30 = 375.0
<br/>
<br/>
3. 0.5 * 30 + 30 + 10 * 30 + 30 + 40 * 2 + 310 + 30 = 795.0 当从 30 扇区旋转到 8 扇区时(更换磁道)，已经超过了 8 扇区的起始点，因此需要多花 310 个时间单位旋转到 8 扇区的起始点
<br/>
<br/>
4. 3.5 * 30 + 2 * 30 + 40 + 320 + 30 * 2 = 585.0


<br/>
<br/>
2.执行上述相同请求,但将寻道速率更改为不同值:-S 2,-S 4,-S 8, -S 10,-S 40, -S 0.1 时间如何变化?

时间为：
<pre>
['195', '195', '195', '195', '195', '195'] # python2 disk.py  -a 0 -c -S 2 /-S 4 /-S 8 ...
['375', '375', '375', '375', '375', '1095']
['795', '435', '435', '435', '435', '2235']
['585', '585', '585', '585', '585', '945']
</pre>

<br/>
<br/>
3.同样的请求,但改变旋转速率:-R O.1,-R 0.5,-R 0.01。时间如何变化?

时间为：
<pre>
['1950', '390', '19500']  # python2 disk.py  -a 0 -c -R 0.1 /-R 0.5 /-R 0.01 ...
['3750', '750', '37501']
['4349', '1590', '43500']
['5850', '1170', '58501']
</pre>

<br/>
<br/>
4.你可能已经注意到,对于一些请求流,一些策略比 FIFO 更好。例如,对于请求流
-a 7,30,8 处理请求的顺序是什么?现在在相同的工作负载上运行最短寻道时间优先
(SSTF)调度程序(-p SSTF)。每个请求服务需要多长时间(寻道、旋转、传输)?

FIFO: 7,30,8
SSTF: 7,8,30

```shell script
python2 disk.py -a 7,30,8 -c # 795
python2 disk.py -a 7,30,8 -c -p SSTF # 375
```

<br/>
<br/>
5.现在做同样的事情,但使用最短的访问时间优先(SATF)调度程序(-SATF)。
它是否对 -a 7,30,8 请求有影响？
找到 SATF 明显优于 SSTF 的一组请求。出现显著差异的条件是什么?

对 -a 7,30,8，SATF 与 SSTF 没有区别
```shell script
python2 disk.py -a 12,31 -c -S 40 -R 3 -p SSTF # Total: 405
python2 disk.py -a 12,31 -c -S 40 -R 3 -p SATF # Total:  65
```
寻道时间远小于旋转时间

<br/>
<br/>
6.你可能已经注意到,该磁盘没有特别好地处理请求流 -a 10,11,12,13。这是为什么?
你可以引入一个磁道偏斜来解决这个问题(-o skew,其中 skew 是一个非负整数)?考
虑到默认寻道速率,偏斜应该是多少,才能尽量减少这一组请求的总时间?对于不同的寻
道速率(例如,-S 2,-S 4)呢?一般来说,考虑到寻道速率和扇区布局信息,你能否写出
一个公式来计算偏斜?

```shell script
python2 disk.py  -a 10,11,12,13 -G
```

寻道时间太长，导致更换磁道时，刚好旋转超过了 12，导致需要重新旋转一个周期

```shell script
python2 disk.py  -a 10,11,12,13 -G -o 2
# 可以看到内圈磁道与外圈磁道偏移了两个扇区
```

<br/>
<br/>
7.多区域磁盘将更多扇区放到外圈磁道中。以这种方式配置此磁盘,请使用 -z 标志运
行。具体来说,尝试运行一些请求,针对使用 -z 10,20,30 的磁盘(这些数字指定了扇区
在每个磁道中占用的角度空间。在这个例子中外圈磁道每隔 10 度 放入一个扇区,中间磁
道每 20 度,内圈磁道每 30 度 一个扇区)。运行一些随机请求(例如,-a -1 -A 5,-1,0,它
通过 -a -1 标志指定使用随机请求,并且生成从 0 到最大值的五个请求),看看你是否可以计
算寻道、旋转和传输时间。使用不同的随机种子(-s 1,-s 2 等)。外圈,中间和内圈磁道的
带宽(每单位时间的扇区数)是多少?

```shell script
python2 disk.py -z 10,20,30 -a -1 -A 5,-1,0 -c -s 1
# REQUESTS [7, 45, 41, 13, 26]
# 7,13,26 为外圈,用时为255，385，120  外圈带宽为：3/(255+385+120) = 0.0039
# 45，41为中间磁道，用时为115，280  中间带宽为为：2/(115+280) = 0.00506
```

<br/>
<br/>
8.调度窗口确定一次磁盘可以接受多少个扇区请求,以确定下一个要服务的扇区。生
成大量请求的某种随机工作负载(例如,-A 1000,-1,0,可能用不同的种子),并查看调
度窗口从 1 变为请求数量时,SATF 调度器需要多长时间(即 -w 1 至 -w 1000,以及其间的一
些值)。需要多大的调度窗口才能达到最佳性能?制作一张图并看看。提示:使用 -c 标志,
不要使用 -G 打开图形,以便更快运行。当调度窗口设置为 1 时,你使用的是哪种策略?

```shell script
python2 disk.py -A 1000,-1,0 -w 1 -p SATF -c    # Total:220125
python2 disk.py -A 1000,-1,0 -w 10 -p SATF -c   # Total:64635
python2 disk.py -A 1000,-1,0 -w 1000 -p SATF -c # Total:35475
```

<br/>
<br/>
9.在调度程序中避免饥饿非常重要。对于 SATF 这样的策略,你能否想到一系列的请
求,导致特定扇区的访问被推迟了很长时间给定序列,如果使用有界的 SATF(bounded
SATF, BSATF)调度方法,它将如何执行?在这种方法中,你可以指定调度窗口(例如 -w
4)以及 BSATF 策略(-p BSATF)。这样,调度程序只在当前窗口中的所有请求都被服务后,
才移动到下一个请求窗口。这是否解决了饥饿问题?与 SATF 相比,它的表现如何?一般来
说,磁盘如何在性能与避免饥饿之间进行权衡?

<br/>
<br/>
10.到目前为止,我们看到的所有调度策略都很贪婪(greedy),因为它们只是选择下
个最佳选项,而不是在一组请求中寻找最优调度。你能找到一组请求,导致这种贪婪方
法不是最优吗?

```shell script
python2 disk.py -a 9,20 -c  # 435
python2 disk.py -a 9,20 -c -p SATF # 465
```
贪婪算法不能保证全局最优，只能保证局部最优.